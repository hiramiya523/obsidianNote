# サービスクラス循環参照問題の解決計画

## 現状の問題点

### 1. 依存性注入の不統一
- `ReservationService`がコンストラクタで`new`を使って直接インスタンス化
- `ReservationCommodityService`も同様に`new`を使用
- `DynamicPackageReservationService`も`new`を使用
- 一部のサービスは`app()->make()`を使用（不統一）

### 2. 循環参照のリスク
```
ReservationService 
  → PaymentBusinessService 
    → (間接的に) ReservationService に戻る可能性

ReservationCommodityService 
  → PaymentBusinessService 
    → (間接的に) ReservationCommodityService に戻る可能性
```

### 3. テストの困難さ
- コンストラクタで直接インスタンス化しているため、モック注入が困難
- 依存関係が隠蔽されている

## 解決策（2025年12月現在のベストプラクティス）

### アプローチ1: 依存性注入の徹底（推奨）

#### 1.1 すべてのサービスをDIコンテナに登録

Laravel 11では、サービスプロバイダの自動発見が改善されていますが、明示的な登録も推奨されます。
専用の`ServiceServiceProvider`を作成：

```php
<?php

namespace App\Providers;

use App\Services\PaymentBusinessService;
use App\Services\ReservationService;
use App\Services\ReservationCommodityService;
use App\Services\ReservationApiService;
use App\Services\DynamicPackageReservationService;
// ... 他のサービス

class ServiceServiceProvider extends ServiceProvider
{
    public function register(): void
    {
        // Laravel 11のベストプラクティス:
        // - ステートレスなサービスは singleton() を使用
        // - ステートフルなサービスや、毎回新しいインスタンスが必要な場合は bind() を使用
        // - 依存関係が複雑な場合はクロージャで明示的に解決
        
        // ステートレスなサービス（シングルトン）
        $this->app->singleton(ReservationApiService::class);
        $this->app->singleton(ReservationLanguageService::class);
        $this->app->singleton(BlobService::class);
        $this->app->singleton(CancelPolicyService::class);
        
        // 依存関係があるサービス（明示的な解決）
        $this->app->singleton(PaymentBusinessService::class, function ($app) {
            return new PaymentBusinessService(
                $app->make(IPaymentGatewayInterface::class)
            );
        });
        
        // ステートフルなサービスや、毎回新しいインスタンスが必要な場合
        $this->app->bind(ReservationCommodityService::class);
        $this->app->bind(ReservationService::class);
        $this->app->bind(DynamicPackageReservationService::class);
    }
}
```

**Laravel 11での singleton vs bind の使い分け:**
- `singleton()`: ステートレスなサービス、設定やキャッシュなど、アプリケーション全体で1つのインスタンスで十分な場合
- `bind()`: ステートフルなサービス、リクエストごとに新しいインスタンスが必要な場合、またはテストでモックを注入しやすいようにする場合

#### 1.2 コンストラクタインジェクションへの変更

**Before:**
```php
class ReservationService
{
    public function __construct()
    {
        $this->o_payment_business_service = new PaymentBusinessService();
        $this->o_rsv_com_srv = new ReservationCommodityService();
    }
}
```

**After:**
```php
readonly class ReservationService
{
    public function __construct(
        private readonly PaymentBusinessService $paymentBusinessService,
        private readonly CancelPolicyService $cancelPolicyService,
        private readonly BlobService $blobService,
        private readonly ReservationApiService $reservationApiService,
        private readonly ReservationChargeTypeService $reservationChargeTypeService,
        private readonly ReservationCommodityService $reservationCommodityService,
        private readonly CustomerPlanService $customerPlanService,
        private readonly RikishaApiService $rikishaApiService,
        private readonly RikishaApiClient $rikishaClient,
        private readonly ReservationLanguageService $reservationLanguageService,
    ) {}
}
```

### アプローチ2: 循環参照の解決パターン

#### 2.1 イベント駆動アーキテクチャ

循環参照を避けるため、イベントを使用：

```php
// PaymentBusinessService
class PaymentBusinessService
{
    public function onCommodityReservationCancel(
        TReservationCommodity $commodity, 
        FormRequest $request
    ): bool {
        // 決済処理
        $result = $this->execCancel($commodity, $request);
        
        // イベント発火（直接呼び出しではなく）
        event(new CommodityReservationCanceled($commodity, $result));
        
        return $result;
    }
}

// ReservationCommodityService
class ReservationCommodityService
{
    public function cancel(int $id, FormRequest $request)
    {
        // 予約キャンセル処理
        $this->cancelReserve($commodity, $request);
        
        // 決済処理はイベントリスナーで処理
        // PaymentBusinessServiceはイベントをリッスンして処理
    }
}
```

#### 2.2 中間サービスの導入

共通の処理を中間サービスに切り出す：

```php
// ReservationPaymentCoordinatorService
class ReservationPaymentCoordinatorService
{
    public function __construct(
        private readonly PaymentBusinessService $paymentService,
        private readonly ReservationCommodityService $commodityService,
    ) {}
    
    public function cancelCommodityReservation(
        int $id, 
        FormRequest $request
    ): void {
        $commodity = TReservationCommodity::findOrFail($id);
        
        // 決済前処理
        $paymentResult = $this->paymentService
            ->onCommodityReservationCancel($commodity, $request);
        
        try {
            // 予約キャンセル処理
            $this->commodityService->cancelReserve($commodity, $request);
        } catch (Throwable $ex) {
            $this->paymentService
                ->onCommodityReservationCancelFailed($commodity, $paymentResult);
            throw $ex;
        }
    }
}
```

#### 2.3 遅延注入（Lazy Loading）

循環参照を避けるため、必要になった時点で注入：

```php
class ReservationService
{
    public function __construct(
        private readonly Container $container,
        // 他の依存関係...
    ) {}
    
    private function getPaymentService(): PaymentBusinessService
    {
        return $this->container->make(PaymentBusinessService::class);
    }
}
```

ただし、この方法は推奨しません。テストが難しくなります。

### アプローチ3: インターフェースの導入

依存関係を抽象化：

```php
interface PaymentServiceInterface
{
    public function onCommodityReservationCancel(
        TReservationCommodity $commodity, 
        FormRequest $request
    ): bool;
}

class PaymentBusinessService implements PaymentServiceInterface
{
    // 実装
}

class ReservationCommodityService
{
    public function __construct(
        private readonly PaymentServiceInterface $paymentService,
    ) {}
}
```

## 推奨実装順序

### Phase 1: 基盤整備
1. `ServiceServiceProvider`を作成
2. すべてのサービスをDIコンテナに登録
3. インターフェースを定義（必要に応じて）

### Phase 2: 依存性注入への移行
1. `ReservationService`のコンストラクタを変更
2. `ReservationCommodityService`のコンストラクタを変更
3. `DynamicPackageReservationService`のコンストラクタを変更
4. 他のサービスも順次変更

### Phase 3: 循環参照の解決
1. 循環参照が発生している箇所を特定
2. イベント駆動または中間サービスで解決
3. テストを追加して動作確認

### Phase 4: テストの追加
1. 各サービスのユニットテストを作成
2. モックを使用したテストを実装
3. 統合テストで全体の動作を確認

## テストしやすい設計のポイント

### 1. 依存性注入の徹底
```php
// テストでモックを注入可能
$mockPaymentService = Mockery::mock(PaymentBusinessService::class);
$service = new ReservationService(
    $mockPaymentService,
    // 他の依存関係...
);
```

### 2. インターフェースの活用
```php
// インターフェースを実装したモックを作成可能
$mockPaymentService = Mockery::mock(PaymentServiceInterface::class);
```

### 3. ファクトリーパターンの活用
```php
class ReservationServiceFactory
{
    public function create(array $dependencies = []): ReservationService
    {
        return new ReservationService(
            $dependencies['paymentService'] ?? app(PaymentBusinessService::class),
            // 他の依存関係...
        );
    }
}
```

## 注意事項

1. **段階的な移行**: 一度にすべてを変更せず、段階的に移行
2. **既存機能の動作確認**: 各フェーズで既存機能が正常に動作することを確認
3. **パフォーマンス**: DIコンテナの使用によるパフォーマンスへの影響を監視
4. **ドキュメント**: 依存関係の変更をドキュメント化

## 2025年12月現在の追加ベストプラクティス

### 1. 型安全性の向上（PHP 8.3対応）

Laravel 11 + PHP 8.3では、より厳密な型チェックが可能です：

```php
readonly class ReservationService
{
    public function __construct(
        private readonly PaymentBusinessService $paymentBusinessService,
        // 型を明示的に指定
    ) {}
}
```

### 2. 属性（Attributes）の活用

PHP 8.3の属性を活用して、依存関係をより明確に：

```php
use Illuminate\Contracts\Container\BindingResolutionException;

class ReservationService
{
    public function __construct(
        #[Inject]
        private readonly PaymentBusinessService $paymentBusinessService,
    ) {}
}
```

### 3. テストの改善

Laravel 11では、テストの書き方がより簡潔になっています：

```php
use Tests\TestCase;
use Mockery;

class ReservationServiceTest extends TestCase
{
    public function test_some_method(): void
    {
        // Laravel 11の新しいテストヘルパー
        $this->mock(PaymentBusinessService::class, function ($mock) {
            $mock->shouldReceive('someMethod')
                ->once()
                ->andReturn(['result' => 'success']);
        });
        
        $service = app(ReservationService::class);
        $result = $service->someMethod();
        
        $this->assertNotNull($result);
    }
}
```

### 4. パフォーマンス最適化

Laravel 11では、サービスコンテナの解決が最適化されていますが、以下の点に注意：

- 不要なシングルトン登録を避ける（メモリ使用量の増加）
- 依存関係の解決順序を最適化
- 遅延ローディングを適切に使用

## 参考資料

- [Laravel 11 Service Container](https://laravel.com/docs/11.x/container)
- [Laravel 11 Service Providers](https://laravel.com/docs/11.x/providers)
- [Dependency Injection Principles](https://en.wikipedia.org/wiki/Dependency_injection)
- [SOLID Principles](https://en.wikipedia.org/wiki/SOLID)
- [PHP 8.3 Attributes](https://www.php.net/manual/en/language.attributes.php)

