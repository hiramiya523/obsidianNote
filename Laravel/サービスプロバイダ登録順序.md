# ServiceServiceProvider の登録順序の重要性

## 結論

**順番は非常に重要です！**

## なぜ順番が重要なのか

### 1. 依存関係の解決順序

Laravelのサービスコンテナは、登録された順序で依存関係を解決しようとします。

```php
// ❌ 間違った順序
$this->app->singleton(ServiceA::class, function ($app) {
    return new ServiceA(
        $app->make(ServiceB::class) // ← ServiceB がまだ登録されていない！
    );
});

$this->app->singleton(ServiceB::class); // 後で登録
```

**問題:** `ServiceA` が `ServiceB` に依存しているが、`ServiceB` がまだ登録されていないため、解決に失敗する可能性があります。

### 2. 循環参照の検出

正しい順序で登録することで、循環参照を早期に発見できます。

```php
// 循環参照の例
$this->app->singleton(ServiceA::class, function ($app) {
    return new ServiceA($app->make(ServiceB::class));
});

$this->app->singleton(ServiceB::class, function ($app) {
    return new ServiceB($app->make(ServiceA::class)); // ← 循環参照！
});
```

### 3. クロージャ内での解決

クロージャ内で `$app->make()` を使用している場合、その時点で依存関係が解決されます。

```php
// 正しい順序
$this->app->singleton(ServiceB::class); // 先に登録

$this->app->singleton(ServiceA::class, function ($app) {
    return new ServiceA(
        $app->make(ServiceB::class) // ← この時点で ServiceB が解決される
    );
});
```

## 正しい登録順序の原則

### 原則1: 依存関係の階層順に登録

```
Level 0: 依存関係がないサービス（基盤サービス）
  ↓
Level 1: Level 0 にのみ依存するサービス
  ↓
Level 2: Level 0-1 に依存するサービス
  ↓
Level 3: Level 0-2 に依存するサービス
  ...
```

### 原則2: 依存されるサービスを先に登録

```php
// ✅ 正しい順序
// 1. 依存されるサービスを先に登録
$this->app->singleton(ServiceB::class);
$this->app->singleton(ServiceC::class);

// 2. 依存するサービスを後に登録
$this->app->singleton(ServiceA::class, function ($app) {
    return new ServiceA(
        $app->make(ServiceB::class),
        $app->make(ServiceC::class)
    );
});
```

## 現在のコードの問題点

### 問題1: 登録順序の不整合

```php
// Line 85-98: ReservationService が CustomerPlanService に依存
$this->app->bind(ReservationService::class, function ($app) {
    return new ReservationService(
        // ...
        $app->make(CustomerPlanService::class), // ← まだ登録されていない！
    );
});

// Line 162-174: CustomerPlanService は後で登録されている
$this->app->singleton(CustomerPlanService::class, function ($app) {
    // ...
});
```

**解決策:** `CustomerPlanService` を `ReservationService` より先に登録する

### 問題2: CommodityService の依存関係

```php
// Line 118-126: CommodityService が CourseChargeCalendarService と CourseChargeCacheService に依存
$this->app->singleton(CommodityService::class, function ($app) {
    return new CommodityService(
        // ...
        $app->make(CourseChargeCalendarService::class), // ← まだ登録されていない！
        $app->make(CourseChargeCacheService::class)     // ← まだ登録されていない！
    );
});

// Line 137-150: これらは後で登録されている
```

**解決策:** `CourseChargeCalendarService` と `CourseChargeCacheService` を `CommodityService` より先に登録する

### 問題3: 循環参照の問題 ⚠️

```php
// CourseChargeCacheService が CourseChargeCalendarService に依存
$this->app->singleton(CourseChargeCacheService::class, function ($app) {
    return new CourseChargeCacheService(
        $app->make(CourseChargeCalendarService::class), // ← 依存
        $app->make(LanguageService::class)
    );
});

// CourseChargeCalendarService が CourseChargeCacheService に依存
$this->app->singleton(CourseChargeCalendarService::class, function ($app) {
    return new CourseChargeCalendarService(
        $app->make(PlanService::class),
        $app->make(LanguageService::class),
        $app->make(CourseChargeCacheService::class) // ← 循環参照！
    );
});
```

**これは循環参照です！** 解決が必要です。

## 循環参照の解決方法

### 方法1: 遅延解決（推奨）

`CourseChargeCalendarService` のコンストラクタで `CourseChargeCacheService` を直接注入せず、必要になった時点で解決：

```php
class CourseChargeCalendarService
{
    private ?CourseChargeCacheService $cacheService = null;
    
    public function __construct(
        private readonly PlanService $planService,
        private readonly LanguageService $languageService,
        private readonly Container $container, // コンテナを注入
    ) {}
    
    private function getCacheService(): CourseChargeCacheService
    {
        if ($this->cacheService === null) {
            $this->cacheService = $this->container->make(CourseChargeCacheService::class);
        }
        return $this->cacheService;
    }
}
```

### 方法2: 中間サービスの導入

循環参照を断ち切る中間サービスを作成：

```php
class CourseChargeCoordinatorService
{
    public function __construct(
        private readonly CourseChargeCalendarService $calendarService,
        private readonly CourseChargeCacheService $cacheService,
    ) {}
    
    // 両方のサービスを協調させるメソッド
}
```

### 方法3: インターフェースの導入

依存関係を抽象化して循環参照を回避：

```php
interface CourseChargeCacheInterface
{
    // メソッド定義
}

class CourseChargeCacheService implements CourseChargeCacheInterface
{
    // 実装
}

class CourseChargeCalendarService
{
    public function __construct(
        private readonly PlanService $planService,
        private readonly LanguageService $languageService,
        private readonly CourseChargeCacheInterface $cacheService, // インターフェースを使用
    ) {}
}
```

## 推奨される登録順序（修正版）

```php
public function register(): void
{
    // ============================================
    // Level 0: 依存関係がないサービス（基盤サービス）
    // ============================================
    $this->app->singleton(CacheService::class);
    $this->app->singleton(LanguageService::class);
    $this->app->singleton(CancelPolicyService::class);
    $this->app->singleton(ReservationLanguageService::class);
    $this->app->singleton(PlanService::class);
    $this->app->singleton(RikishaApiClient::class);
    $this->app->singleton(RikishaCacheService::class);
    $this->app->singleton(TabioneApiService::class);
    $this->app->singleton(ReservationApiService::class);
    $this->app->singleton(ReservationChargeTypeService::class);

    // ============================================
    // Level 1: Level 0 にのみ依存するサービス
    // ============================================
    $this->app->singleton(BlobService::class, function ($app) {
        return new BlobService($app->make(CacheService::class));
    });

    $this->app->singleton(RikishaApiService::class, function ($app) {
        return new RikishaApiService(
            $app->make(RikishaApiClient::class),
            $app->make(RikishaCacheService::class)
        );
    });

    $this->app->singleton(PaymentBusinessService::class, function ($app) {
        return new PaymentBusinessService(
            $app->make(IPaymentGatewayInterface::class)
        );
    });

    // ============================================
    // Level 2: 予約関連サービス（他の予約サービスに依存しない）
    // ============================================
    $this->app->bind(ReservationCommodityService::class, function ($app) {
        return new ReservationCommodityService(
            $app->make(PaymentBusinessService::class),
            $app->make(RikishaApiClient::class),
            $app->make(RikishaApiService::class)
        );
    });

    // ============================================
    // Level 3: コース料金関連サービス
    // ============================================
    // 注意: CourseChargeCalendarService と CourseChargeCacheService は循環参照の可能性あり
    // 解決策: 遅延解決または中間サービスを使用
    
    // まず、CourseChargeCalendarService を登録（循環参照を避けるため遅延解決を使用）
    $this->app->singleton(CourseChargeCalendarService::class, function ($app) {
        return new CourseChargeCalendarService(
            $app->make(PlanService::class),
            $app->make(LanguageService::class),
            // CourseChargeCacheService への依存は遅延解決される
        );
    });
    
    $this->app->singleton(CourseChargeCacheService::class, function ($app) {
        return new CourseChargeCacheService(
            $app->make(LanguageService::class),
            $app->make(CourseChargeCalendarService::class) // Level 3 で登録済み
        );
    });

    $this->app->singleton(CourseStockCalendarService::class, function ($app) {
        return new CourseStockCalendarService(
            $app->make(ReservationCommodityService::class) // Level 2 で登録済み
        );
    });

    $this->app->singleton(CourseChargeService::class, function ($app) {
        return new CourseChargeService(
            $app->make(CourseStockCalendarService::class),
            $app->make(CourseChargeCalendarService::class),
            $app->make(LanguageService::class),
            $this->app->make(CourseChargeCacheService::class)
        );
    });

    $this->app->singleton(CommodityService::class, function ($app) {
        return new CommodityService(
            $app->make(CacheService::class),
            $app->make(LanguageService::class),
            $app->make(PlanService::class),
            $app->make(CourseChargeCalendarService::class), // Level 3 で登録済み
            $app->make(CourseChargeCacheService::class)     // Level 3 で登録済み
        );
    });

    // ============================================
    // Level 4: Customer サービス
    // ============================================
    $this->app->singleton(CustomerPlanService::class, function ($app) {
        return new CustomerPlanService(
            $app->make(CommodityService::class),           // Level 3 で登録済み
            $app->make(PlanService::class),
            $app->make(CourseChargeCalendarService::class),
            $app->make(CourseStockCalendarService::class),
            $app->make(LanguageService::class),
            $app->make(BlobService::class),
            $app->make(CourseChargeService::class),
            $app->make(CourseChargeCacheService::class),
            $app->make(TabioneApiService::class)
        );
    });

    // ============================================
    // Level 5: 予約サービス（CustomerPlanService に依存）
    // ============================================
    $this->app->bind(ReservationService::class, function ($app) {
        return new ReservationService(
            $app->make(PaymentBusinessService::class),
            $app->make(CancelPolicyService::class),
            $app->make(BlobService::class),
            $app->make(ReservationApiService::class),
            $app->make(ReservationChargeTypeService::class),
            $app->make(ReservationCommodityService::class),
            $app->make(CustomerPlanService::class), // Level 4 で登録済み ✅
            $app->make(RikishaApiClient::class),
            $app->make(RikishaApiService::class),
            $app->make(ReservationLanguageService::class)
        );
    });

    $this->app->bind(DynamicPackageReservationService::class, function ($app) {
        return new DynamicPackageReservationService(
            $app->make(ReservationService::class),          // Level 5 で登録済み
            $app->make(ReservationApiService::class),
            $app->make(PaymentBusinessService::class),
            $app->make(ReservationLanguageService::class),
            $app->make(RikishaApiClient::class),
            $app->make(RikishaApiService::class),
            $app->make(CustomerPlanService::class)
        );
    });

    $this->app->bind(CustomerReservationService::class, function ($app) {
        return new CustomerReservationService(
            $app->make(ReservationService::class),
            $app->make(DynamicPackageReservationService::class),
            $app->make(PaymentBusinessService::class),
            $app->make(LanguageService::class),
            $app->make(PlanService::class),
            $app->make(RikishaApiClient::class)
        );
    });
}
```

## 注意事項

### 1. コンストラクタインジェクションへの変更が必要

現在、多くのサービスがまだ `new` で直接インスタンス化しているため、`ServiceServiceProvider` での登録は、実際にコンストラクタインジェクションに変更されるまで待つ必要があります。

### 2. 循環参照の確認

`CourseChargeCalendarService` と `CourseChargeCacheService` の間には循環参照のリスクがあります。実際のコンストラクタを確認して、適切に解決する必要があります。

### 3. テストの重要性

登録順序を変更した後は、必ずテストを実行して動作確認を行ってください。

## まとめ

**登録順序は非常に重要です！**

1. ✅ 依存関係がないサービスを先に登録
2. ✅ 依存関係があるサービスを後に登録
3. ✅ 依存関係の階層を意識して登録順序を決定
4. ⚠️ 循環参照が発生している場合は、遅延解決または中間サービスで解決

現在のコードには順序の問題と循環参照の問題があるため、修正が必要です。

