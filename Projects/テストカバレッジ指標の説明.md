---
title: テストカバレッジ指標の説明
created: 2025-12-02
updated: 2025-12-02
tags:
  - testing
  - code-coverage
  - reference
  - phpunit
aliases:
  - カバレッジ指標
  - Coverage Metrics
  - テスト指標
---

# テストカバレッジ指標の説明

> [!abstract] 概要
> テストカバレッジレポートに含まれる3つの主要指標（Lines、Functions/Methods、Classes/Traits）の詳細な説明と解釈方法をまとめたリファレンスドキュメントです。
> 
> 関連ドキュメント: [[テストカバレッジ改善計画]]

---

## 📋 目次

- [[#カバレッジ指標の概要|カバレッジ指標の概要]]
- [[#Lines（行カバレッジ）|Lines（行カバレッジ）]]
- [[#Functions/Methods（関数・メソッドカバレッジ）|Functions/Methods（関数・メソッドカバレッジ）]]
- [[#Classes/Traits（クラス・トレイトカバレッジ）|Classes/Traits（クラス・トレイトカバレッジ）]]
- [[#3つの指標の関係性|3つの指標の関係性]]
- [[#どの指標を重視すべきか|どの指標を重視すべきか]]

---

## 📊 カバレッジ指標の概要

テストカバレッジレポートには、3つの主要な指標があります。それぞれ異なる観点からコードのテスト状況を表しています。

| 指標 | 粒度 | 測定内容 | 用途 |
|------|------|---------|------|
| **Lines** | 細かい | 実行されたコード行 | 詳細なテスト状況の把握 |
| **Functions/Methods** | 中程度 | 呼び出された関数・メソッド | 関数・メソッド単位でのテスト状況 |
| **Classes/Traits** | 粗い | 使用されたクラス・トレイト | アーキテクチャレベルのテスト状況 |

---

## 1. Lines（行カバレッジ）

### 定義

> [!info] Lines（行カバレッジ）
> **実行されたコード行の割合**
> 
> - テスト実行時に**実際に実行されたコード行数**を測定
> - 全コード行数に対する実行された行数の割合

### 計算式

```
Linesカバレッジ = (実行された行数 / 全コード行数) × 100
```

### 具体例

```
Lines: 4.00% (785 / 19,624行)
```

**意味：**
- 全19,624行のコードのうち、785行がテストで実行された
- 残り18,839行（96%）はテストで実行されていない

### どの行がカウントされるか

**カウントされる行：**
- 実行可能なコード行（変数代入、関数呼び出し、条件分岐など）
- クラス定義、関数定義の宣言行

**カウントされない行：**
- コメント（`//`、`/* */`）
- 空行
- 閉じ括弧のみの行（`}`）

### コード例

```php
<?php
// このコメント行はカウントされない

class ReservationService  // この行はカウントされる
{
    public function create($data)  // この行はカウントされる
    {
        // このコメント行はカウントされない
        
        if ($data === null) {  // この行はカウントされる
            return null;  // この行はカウントされる（テストで実行された場合）
        }
        
        return $this->repository->save($data);  // この行はカウントされる（テストで実行された場合）
    }  // この行はカウントされない（閉じ括弧のみ）
}
```

### メリットとデメリット

**メリット：**
- ✅ **直感的で理解しやすい**
- ✅ **全体のテスト状況を把握しやすい**
- ✅ **最も一般的な指標**

**デメリット：**
- ⚠️ **複雑なロジックの詳細が分からない**
- ⚠️ **条件分岐の網羅性が分からない**

---

## 2. Functions/Methods（関数・メソッドカバレッジ）

### 定義

> [!info] Functions/Methods（関数・メソッドカバレッジ）
> **実行された関数・メソッドの割合**
> 
> - テスト実行時に**実際に呼び出された関数・メソッド数**を測定
> - 全関数・メソッド数に対する実行された関数・メソッド数の割合

### 計算式

```
Functions/Methodsカバレッジ = (実行された関数・メソッド数 / 全関数・メソッド数) × 100
```

### 具体例

```
Functions/Methods: 5.98% (102 / 1,705個)
```

**意味：**
- 全1,705個の関数・メソッドのうち、102個がテストで呼び出された
- 残り1,603個（94%）の関数・メソッドはテストで呼び出されていない

### どの関数・メソッドがカウントされるか

**カウントされるもの：**
- クラスのメソッド（`public`、`protected`、`private`）
- グローバル関数
- クロージャ（無名関数）
- マジックメソッド（`__construct`、`__get`など）

**カウントされないもの：**
- インターフェースのメソッド宣言（実装がないため）
- 抽象メソッドの宣言（実装がないため）

### コード例

```php
class ReservationService
{
    public function create($data)  // このメソッドがカウントされる
    {
        // テストで呼び出された場合、カウントされる
    }
    
    public function update($id, $data)  // このメソッドがカウントされる
    {
        // テストで呼び出されなかった場合、カウントされない
    }
    
    private function validate($data)  // このメソッドがカウントされる
    {
        // テストで間接的に呼び出された場合、カウントされる
    }
}

// グローバル関数もカウントされる
function helper_function()  // この関数がカウントされる
{
    // テストで呼び出された場合、カウントされる
}
```

### メリットとデメリット

**メリット：**
- ✅ **関数・メソッド単位でのテスト状況が分かる**
- ✅ **未テストの関数・メソッドを特定しやすい**
- ✅ **リファクタリング時の影響範囲を把握しやすい**

**デメリット：**
- ⚠️ **関数・メソッド内の詳細な実行状況が分からない**
- ⚠️ **条件分岐の網羅性が分からない**

---

## 3. Classes/Traits（クラス・トレイトカバレッジ）

### 定義

> [!info] Classes/Traits（クラス・トレイトカバレッジ）
> **実行されたクラス・トレイトの割合**
> 
> - テスト実行時に**実際に使用されたクラス・トレイト数**を測定
> - 全クラス・トレイト数に対する実行されたクラス・トレイト数の割合

### 計算式

```
Classes/Traitsカバレッジ = (実行されたクラス・トレイト数 / 全クラス・トレイト数) × 100
```

### 具体例

```
Classes/Traits: 5.38% (21 / 390個)
```

**意味：**
- 全390個のクラス・トレイトのうち、21個がテストで使用された
- 残り369個（94.6%）のクラス・トレイトはテストで使用されていない

### どのクラス・トレイトがカウントされるか

**カウントされるもの：**
- 通常のクラス（`class`）
- 抽象クラス（`abstract class`）
- トレイト（`trait`）
- インターフェース（`interface`）- 実装クラスが使用された場合

**カウントされる条件：**
- クラスがインスタンス化された（`new ClassName()`）
- クラスのメソッドが呼び出された
- クラスの静的メソッドが呼び出された
- トレイトが使用された（`use TraitName;`）

### コード例

```php
// このクラスがカウントされる（テストで使用された場合）
class ReservationService
{
    public function create($data)
    {
        return new Reservation($data);  // Reservationクラスもカウントされる
    }
}

// このクラスがカウントされない（テストで使用されなかった場合）
class UnusedService
{
    public function doSomething()
    {
        // テストで呼び出されなかった
    }
}

// このトレイトがカウントされる（テストで使用された場合）
trait Loggable
{
    public function log($message)
    {
        // テストで使用された
    }
}
```

### メリットとデメリット

**メリット：**
- ✅ **クラス・トレイトレベルでのテスト状況が分かる**
- ✅ **未テストのクラス・トレイトを特定しやすい**
- ✅ **アーキテクチャレベルの問題を把握しやすい**

**デメリット：**
- ⚠️ **クラス内の詳細な実行状況が分からない**
- ⚠️ **クラスの一部のメソッドだけがテストされていても、クラス全体がカバーされたとカウントされる**

---

## 📊 3つの指標の関係性

### 指標の階層構造

```
Classes/Traits (クラス・トレイトレベル)
    ↓
Functions/Methods (関数・メソッドレベル)
    ↓
Lines (コード行レベル)
```

> [!tip] 階層構造の意味
> より粗い粒度の指標（Classes/Traits）が高い場合、細かい粒度の指標（Lines）も高いことが期待されます。逆に、細かい粒度の指標が低い場合、粗い粒度の指標も低くなる傾向があります。

### 指標の解釈

#### 理想的な状況

> [!success] 理想的な状況
> 3つの指標が**ほぼ同じ値**であることが理想
> 
> **例：** Lines: 80%、Functions: 78%、Classes: 82% → バランスが良い

#### 問題がある状況

> [!warning] 問題がある状況
> 
> **1. Linesが低いが、Functionsが高い**
> - 関数は呼び出されているが、関数内のコードが十分に実行されていない
> - **例：** Lines: 20%、Functions: 60% → 関数内の条件分岐がテストされていない可能性
> 
> **2. Functionsが低いが、Classesが高い**
> - クラスは使用されているが、クラス内のメソッドが十分にテストされていない
> - **例：** Functions: 30%、Classes: 70% → クラスの一部のメソッドだけがテストされている

### 現在のプロジェクトの状況

```
Lines: 4.00% (785 / 19,624行)
Functions/Methods: 5.98% (102 / 1,705個)
Classes/Traits: 5.38% (21 / 390個)
```

> [!info] 分析結果
> - 3つの指標が**ほぼ同じレベル**（4-6%）
> - これは**全体的にテストが不足している**ことを示している
> - 特定の領域だけがテストされているわけではなく、**全体的にテストが少ない**
> 
> **解釈：**
> - テストされているクラス・メソッド・コード行が**バランス良く**テストされている
> - ただし、**全体のテスト量が非常に少ない**
> - 改善が必要な領域が**広範囲にわたる**

---

## 🎯 どの指標を重視すべきか

### 一般的な推奨

> [!tip] 推奨アプローチ
> 
> 1. **Lines（行カバレッジ）を主要指標とする**
>    - 最も詳細な情報を提供
>    - 最も一般的な指標
>    - 目標設定がしやすい
> 
> 2. **Functions/Methodsを補助指標とする**
>    - 関数・メソッド単位での改善状況を把握
>    - 未テストの関数・メソッドを特定
> 
> 3. **Classes/Traitsを参考指標とする**
>    - アーキテクチャレベルの問題を把握
>    - 未テストのクラス・トレイトを特定

### 目標設定の例

| 期間 | Lines | Functions/Methods | Classes/Traits |
|------|-------|------------------|----------------|
| **短期目標（3ヶ月）** | 20% | 25% | 30% |
| **中期目標（6ヶ月）** | 50% | 55% | 60% |
| **長期目標（1年）** | 80% | 85% | 90% |

> [!note] 注意
> Classes/Traitsの目標を少し高めに設定する理由：
> - クラス全体が使用されれば、そのクラスはカバーされたとカウントされる
> - ただし、クラス内のすべてのメソッドがテストされているわけではない

---

## 📝 まとめ

### 各指標の意味

| 指標 | 意味 | 現在の値 |
|------|------|---------|
| **Lines** | 実行されたコード行の割合 | 4.00% (785/19,624行) |
| **Functions/Methods** | 呼び出された関数・メソッドの割合 | 5.98% (102/1,705個) |
| **Classes/Traits** | 使用されたクラス・トレイトの割合 | 5.38% (21/390個) |

### 重要なポイント

> [!important] 重要なポイント
> 
> 1. **3つの指標は異なる観点からテスト状況を表している**
> 2. **すべての指標が低い = 全体的にテストが不足している**
> 3. **指標のバランスが重要**
> 4. **Linesを主要指標として、他の指標を補助的に使用する**

### 次のステップ

1. **現状の理解**
   - 3つの指標の意味を理解する
   - 現在の値が何を意味するかを把握する

2. **目標設定**
   - 各指標の目標値を設定する
   - 段階的な改善計画を立てる

3. **改善実施**
   - 優先順位の高い領域からテストを追加
   - 定期的にカバレッジを確認

---

## 関連ノート

- [[テストカバレッジ改善計画]] - 改善計画とアクションプラン
- [[AI開発移行計画]] - Phase 1でテスト基盤の構築が重要

---

> [!note] 更新履歴
> - 2025-12-02: 初版作成（Obsidian向けに整理）
